<!DOCTYPE html>
<html lang="en-nz">

<head>
    <meta charset="utf-8">
    <title>{% block title %}{% endblock %}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@200;400;600;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.css"/>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
<nav>
    <div class="header">
        <div class="navbar-brand">Māori Dictionary</div>
        <div class="navbar-links">
            <a id="home" href="/">home</a>
            <a id="categories" href="/categories/all-categories/1">categories</a>
            {# Do administrator checks here #}
            {% if administrator %}
                <a id="admin" href="/admin">admin</a>
            {% else %}
                <a id="admin" href="/admin" class="hidden">admin</a>
            {% endif %}
            {% if logged_in_clean %}
                <a id="logout" href="/logout">logout</a>
                <a id="login" data-target="#loginModal" role="button" data-toggle="modal" class="hidden">login</a>
            {% else %}
                <a id="login" data-target="#loginModal" role="button" data-toggle="modal">login</a>
                <a id="logout" href="/logout" class="hidden">logout</a>
            {% endif %}
        </div>
    </div>
</nav>
<!--Manage the class of the container, the header text, and the page header (a subheader)-->
<div class="{% block container %}{% endblock %}">
    <header>
        <h1>{% block header %}{% endblock %}</h1>
        <h2>{% block pageheading %}{% endblock %}</h2>
    </header>

    <main>
        {% block main %}
        {% endblock %}
    </main>
</div>
</body>

{# Login Modal #}
 <div id="loginModal" class="modal fade">
      <div class="modal-dialog">
           <div class="modal-content">
                <div class="modal-header">
                     <button type="button" class="close" data-dismiss="modal">×</button>
                     <h4 class="modal-title">Login</h4>
                </div>
                <div class="modal-body">
                    <form class="loginform" method="POST" onsubmit="return ValidateLoginForm()">
                        <input type="hidden" name="loginform" value=""/>
                        <div id="login-incorrect" class="incorrect"></div>
                        <div class="form-login-email">
                            <label for="login-username" class="form-label">Email or Username</label>
                            <input type="text" name="login-username" id="login-username" class="form-element"/>
                        </div>
                        <div class="field-incomplete" id="login-username-incomplete"></div>
                        <div class="form-login-password">
                            <label for="login-password" class="form-label" id="login-password-text">Password</label>
                            <input type="password" name="login-password" id="login-password" class="form-element">
                        </div>
                        <div class="field-incomplete" id="login-password-incomplete"></div>
                        <label for="login-show-password" class="show-password form-label">
                            <input type="checkbox" id="login-show-password" onclick="return showLoginPassword()">
                            Show Password
                        </label>
                        <div class="form-login-submit">
                            <input type="submit" value="Login" class="form-submit" id="login-submit">
                        </div>
                        <div class="forgot-password">
                            <p><a data-target="#forgotPasswordModal" role="button" data-toggle="modal" class="closeLoginModal">Forgot Password?</a></p>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <p>Don't have an account yet? <a data-target="#signUpModal" role="button" data-toggle="modal" class="closeLoginModal">Sign Up</a>.</p>
                </div>
           </div>
      </div>
 </div>

{# Forgot Password #}
<div id="forgotPasswordModal" class="modal fade">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                 <button type="button" class="close" data-dismiss="modal">×</button>
                 <h4 class="modal-title">Forgot your Password?</h4>
            </div>
            <div class="modal-body">
                <form class="forgotpasswordform" id="forgotpasswordform" method="POST" onsubmit="return ValidateForgotPasswordForm()">
                    <div id="forgotpassword-incorrect" class="incorrect"></div>
                    {# First name field #}
                    <label for="forgotpassword-firstname" class="form-label">First Name</label>
                    <input type="text" name="forgotpassword-firstname" id="forgotpassword-firstname" class="form-element"/>
                    <div class="field-incomplete" id="forgotpassword-firstname-incomplete"></div>
                    {# Last name field #}
                    <label for="forgotpassword-lastname" class="form-label">Last Name</label>
                    <input type="text" name="forgotpassword-lastname" id="forgotpassword-lastname" class="form-element"/>
                    <div class="field-incomplete" id="forgotpassword-lastname-incomplete"></div>
                    {# Username field #}
                    <label for="forgotpassword-username" class="form-label">Username</label>
                    <input type="text" name="forgotpassword-username" id="forgotpassword-username" class="form-element"/>
                    <div class="field-incomplete" id="forgotpassword-username-incomplete"></div>
                    {# Email field #}
                    <label for="forgotpassword-email" class="form-label">Email</label>
                    <input type="text" name="forgotpassword-email" id="forgotpassword-email" class="form-element"/>
                    <div class="field-incomplete" id="forgotpassword-email-incomplete"></div>
                    {# Password field #}
                    <label for="forgotpassword-password" class="form-label">Password</label>
                    <input type="password" name="forgotpassword-password" id="forgotpassword-password" class="form-element"/>
                    <div class="field-incomplete" id="forgotpassword-password-incomplete"></div>
                    {# Confirm password field #}
                    <label for="forgotpassword-confirmpassword" class="form-label">Confirm Password</label>
                    <input type="password" name="forgotpassword-confirmpassword" id="forgotpassword-confirmpassword" class="form-element"/>
                    <div class="field-incomplete" id="forgotpassword-confirmpassword-incomplete"></div>
                    {# Show password #}
                    <label for="forgotpassword-show-password" class="show-password form-label">
                        <input type="checkbox" id="forgotpassword-show-password" onclick="return showForgotPasswordPassword()">
                        Show Password
                    </label>
                    {# Submit #}
                    <div id="form-forgotpassword-submit">
                        <input type="submit" value="Reset Password" class="form-submit" id="forgotpassword-submit">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <p>Already have an account? <a data-target="#loginModal" role="button" data-toggle="modal" id="closeForgotPasswordModal">Login</a>.</p>
            </div>
        </div>
    </div>
</div>

{# Sign Up Modal #}
<div id="signUpModal" class="modal fade">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                 <button type="button" class="close" data-dismiss="modal">×</button>
                 <h4 class="modal-title">Sign Up</h4>
            </div>
            <div class="modal-body">
                <form class="signupform" id="signupform" method="POST" onsubmit="return ValidateSignUpForm()">
                    <input type="hidden" id="signup-form" name="signup-form" value=""/>
                    {# Student teacher button #}
                    <div class="student-teacher-button" id="student-teacher-button">
                        <button type="button" class="button-student-teacher" id="student-button">Student</button><button type="button" class="button-student-teacher" id="teacher-button">Teacher</button>
                    </div>
                    <div class="field-incomplete" id="signup-button-incomplete"></div>
                    <input type="hidden" name="teacherButton" id="teacherButton" value="Student"/>
                    {# First name field #}
                    <label for="signup-firstname" class="form-label">First Name</label>
                    <input type="text" name="signup-firstname" id="signup-firstname" class="form-element"/>
                    <div class="field-incomplete" id="signup-firstname-incomplete"></div>
                    {# Last name field #}
                    <label for="signup-lastname" class="form-label">Last Name</label>
                    <input type="text" name="signup-lastname" id="signup-lastname" class="form-element"/>
                    <div class="field-incomplete" id="signup-lastname-incomplete"></div>
                    {# Username field #}
                    <label for="signup-username" class="form-label">Username</label>
                    <input type="text" name="signup-username" id="signup-username" class="form-element"/>
                    <div class="field-incomplete" id="signup-username-incomplete"></div>
                    {# Email field #}
                    <label for="signup-email" class="form-label">Email</label>
                    <input type="text" name="signup-email" id="signup-email" class="form-element"/>
                    <div class="field-incomplete" id="signup-email-incomplete"></div>
                    {# Password field #}
                    <label for="signup-password" class="form-label">Password</label>
                    <input type="password" name="signup-password" id="signup-password" class="form-element"/>
                    <div class="field-incomplete" id="signup-password-incomplete"></div>
                    {# Confirm password field #}
                    <label for="signup-confirmpassword" class="form-label">Confirm Password</label>
                    <input type="password" name="signup-confirmpassword" id="signup-confirmpassword" class="form-element"/>
                    <div class="field-incomplete" id="signup-confirmpassword-incomplete"></div>
                    {# Show password #}
                    <label for="signup-show-password" class="show-password form-label">
                        <input type="checkbox" id="signup-show-password" onclick="return showSignUpPassword()">
                        Show Password
                    </label>
                    {# Submit #}
                    <div id="form-signup-submit">
                        <input type="submit" value="Sign Up" class="form-submit" id="signup-submit">
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <p>Already have an account? <a data-target="#loginModal" role="button" data-toggle="modal" id="closeSignUpModal">Login</a>.</p>
            </div>
        </div>
    </div>
</div>
<script>
    function postAjax(directedUrl, formData, reload, redirect, url) {
        /**
        This function is for posting to a direct url using AJAX
        :param directedUrl: The url which the post is directed to
        :param formData: The form data which is provided
        :param reload: If the page should be reloaded after the data has been posted
        :param redirect: Redirect to another webpage
        :param url: The webpage to redirect to (only used if redirect is true)
         */
        $.ajax({
            type: 'POST',
            url: directedUrl,
            contentType: "application/json",
            data: JSON.stringify(formData),
            success: function() {
                if (reload) { // Reload the page after the data has been posted
                    location.reload()
                } else if (redirect) {
                    location.href = url
                }
            }
        })
    }

    function showLoginPassword() {
        /**
         * This function is for displaying the password on the login modal
         * This is done by changing the type between password and text with a ternary operator
         */
        const showPassword = document.getElementById("login-password")
        showPassword.type === "password" ? showPassword.type = "text" : showPassword.type = "password"
    }

    function showForgotPasswordPassword() {
        /**
         * This function is for displaying the password on the forgot password modal
         * This is done by changing the display type of the inputs between text and password
         */
        const showPassword = document.getElementById("forgotpassword-password")
        const showConfirmPassword = document.getElementById("forgotpassword-confirmpassword")
        if (showPassword.type === "password") {
            showPassword.type = "text"
            showConfirmPassword.type = "text"
        } else {
            showPassword.type = "password"
            showConfirmPassword.type = "password"
        }
    }

    function showSignUpPassword() {
        /**
         * This function is for displaying the password on the signup modal
         * This is done by changing the display type of the inputs between text and password
         */
        const showPassword = document.getElementById("signup-password")
        const showConfirmPassword = document.getElementById("signup-confirmpassword")
        if (showPassword.type === "password") {
            showPassword.type = "text"
            showConfirmPassword.type = "text"
        } else {
            showPassword.type = "password"
            showConfirmPassword.type = "password"
        }
    }

    function checkLogin(logged_in, admin) {
        /**
         * This function is for checking if the user is logged in
         * This will control the display of the login element, logout element, and admin element
         * :param logged_in: If the user is logged in or not
         * :param admin: If the user is an administrator or not
         */
        const loginElement = document.getElementById("login")
        const logoutElement = document.getElementById("logout")
        const adminElement = document.getElementById("admin")
        /* The .contains() function and the .add() functions use the exact same native code for searching
        through the unique set to see if it contains the class. So it's unnecessary as the function will abort. */
        if (logged_in) {
            loginElement.classList.add("hidden")
            logoutElement.classList.remove("hidden")
            if (admin) {
                adminElement.classList.remove("hidden")
            } else {
                adminElement.classList.add("hidden")
            }
        } else {
            loginElement.classList.remove("hidden")
            logoutElement.classList.add("hidden")
            adminElement.classList.add("hidden")
        }
    }

    function setValue(colourId, colour, textId, text, fail) {
        /**
         * This function is for setting the value of an element
         * This is especially useful for alerting a user if their input is invalid
         * :param colourId: The element to apply the colour to (as a border colour)
         * :param colour: The colour for the border colour
         * :param textId: The element to apply the text to (as innerText)
         * :param text: The text to apply to the element
         * :param fail: This parameter is parsed through the function to define a value,
         * the fail parameter isn't required
         * :return fail: This will return the fail which has been parsed through,
         * this can return null if the fail parameter isn't being used
         */
        document.getElementById(colourId).style.borderColor = colour
        document.getElementById(textId).innerText = text
        return fail
    }

    function clearValue(inputValues) {
        /**
         * Function for clearing the value of elements based on their respective ids
         * :param inputValues: An array of element ids to set their value to an empty string
         */
        for (const value of inputValues) {
            document.getElementById(value).value = ""
        }
    }

    function clearText(inputText) {
        /**
         * Function for clearing the text of elements based on their respective ids
         * :param inputText: An array of element ids to set their inner text to an empty string
         */
        for (const text of inputText) {
            document.getElementById(text).innerText = ""
        }
    }

    function clearColour(inputColour) {
        /**
         * Function for clearing the border colour of elements based on their respective ids
         * :param inputColour: An array of element ids to set their border colour to black
         */
        for (const colour of inputColour) {
            document.getElementById(colour).style.borderColor = "#000"
        }
    }

    function removeTeacherButtonInput() {
        /**
         * Function for removing the teacher input, this will remove the active class from the teacher button
         */
        const teacherButton = document.getElementById("teacher-button")
        if (teacherButton.classList.contains("active")) {
            teacherButton.classList.remove("active")
        }
    }

    function removeStudentButtonInput() {
        /**
         * Function for removing the student input, this will remove the active class from the student button
         */
        const studentButton = document.getElementById("student-button")
        if (studentButton.classList.contains("active")) {
            studentButton.classList.remove("active")
        }
    }

    // Manage the variables for the login/forgot password/signup modals
    const failedTextColour = "#e54b72"
    const firstnameMaxLength = 64
    const lastnameMaxLength = 64
    const usernameMaxLength = 32
    const emailMaxLength = 256
    const emailMinLength = 4
    const passwordMinLength = 8
    const passwordMaxLength = 128

    // For admin
    const wordMaxLength = 72
    const definitionMaxLength = 128
    const maxImageLength = 128
    const maxImageSize = 15728640 /* Max image size in bytes (15mb) */
    const categoryMaxLength = 32

    // Information about all of the modals
    const loginModal = $('#loginModal')
    const forgotPasswordModal = $('#forgotPasswordModal')
    const signUpModal = $('#signUpModal')
    const addWordModal = $('#addWordModal')
    const deleteWordModal = $('#deleteWordModal')
    const addCategoryModal = $('#addCategoryModal')
    const deleteCategoryModal = $('#deleteCategoryModal')
    const directDeleteWordModal = $('#directDeleteWordModal')

    function ValidateLoginForm() {
        /**
         * This function is for validating the login form by fetching the login information from app.py
         * :return: false in order to cancel the submission of the form so that it can be managed via AJAX
         */
        (async () => { // Use an async to get whether the username & email are already used in the database
            try {
                // .trim() is used to clear the whitespace at start/end of string
                const emailUsernameInput = document.getElementById("login-username").value.trim()
                const passwordInput = document.getElementById("login-password").value.trim()
                const data = {emailusername: emailUsernameInput, password: passwordInput}
                const response = await fetch('/getlogininformation', { // fetch /getlogininformation from app.py
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(data) // parse through the data (email and username input)
                })
                const responseText = await response.json() // wait for the response
                clearText(["login-incorrect", "login-username-incomplete", "login-password-incomplete"])
                clearColour(["login-username", "login-password"])
                let fail = false
                // Don't notify the user of the email/username/password constraints (security reasons)
                if (emailUsernameInput.length === 0) {
                    fail = setValue("login-username", failedTextColour, "login-username-incomplete", ".Email or Username is required", true)
                }
                if (passwordInput.length === 0) {
                    fail = setValue("login-password", failedTextColour, "login-password-incomplete", ".Password is required", true)
                }
                if (emailUsernameInput.length > 0 && passwordInput.length > 0 && !responseText.validLogin) {
                    document.getElementById("login-incorrect").innerText = "Incorrect email/username or password"
                    document.getElementById("login-username").style.borderColor = failedTextColour
                    document.getElementById("login-password").style.borderColor = failedTextColour
                    fail = true
                }
                if (!fail) {
                    checkLogin(true, responseText.administrator)
                    const formData = {
                        "type": "login",
                        "userid": responseText.userId
                    }
                    postAjax("/login", formData, false, false, "") // Why isnt this working?
                    loginModal.modal('hide') // close login up modal
                }
            } catch (error) {
                console.error(error)
            }
        })()
        return false
    }

    function ValidateForgotPasswordForm() {
        /**
         * This function is for validating the forgot password form
         * :return: false in order to cancel the submission of the form so that it can be managed via AJAX
         */
        (async () => { // Use an async to get whether this data exists in the database for the password reset
            try { // use try catch just in case
                const firstNameInput = document.getElementById("forgotpassword-firstname").value.trim()
                const lastNameInput = document.getElementById("forgotpassword-lastname").value.trim()
                const usernameInput = document.getElementById("forgotpassword-username").value.trim()
                const emailInput = document.getElementById("forgotpassword-email").value.trim()
                const passwordInput = document.getElementById("forgotpassword-password").value.trim()
                const confirmPasswordInput = document.getElementById("forgotpassword-confirmpassword").value.trim()
                const data = {firstname: firstNameInput, lastname: lastNameInput, username: usernameInput, email: emailInput}
                const response = await fetch('/getchangepasswordinformation', { // fetch /getchangepasswordinformation from app.py
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(data) // parse through the data (email and username input)
                })
                const responseText = await response.json() // wait for the response
                document.getElementById("forgotpassword-incorrect").classList.remove("successful")
                clearText(["forgotpassword-incorrect", "forgotpassword-firstname-incomplete", "forgotpassword-lastname-incomplete", "forgotpassword-username-incomplete",
                    "forgotpassword-email-incomplete", "forgotpassword-password-incomplete", "forgotpassword-confirmpassword-incomplete"])
                clearColour(["forgotpassword-firstname", "forgotpassword-lastname", "forgotpassword-username", "forgotpassword-email", "forgotpassword-password", "forgotpassword-confirmpassword"])
                let fail = false // variable used throughout to check if the data is valid
                // Iterate over fields to check if they have any input, if they don't notify their respected error message
                const elementsToCheck = ["forgotpassword-firstname", "forgotpassword-lastname", "forgotpassword-username", "forgotpassword-email", "forgotpassword-password",
                    "forgotpassword-confirmpassword"]
                const elementMessages = {
                    "forgotpassword-firstname": ".First name is required",
                    "forgotpassword-lastname": ".Last name is required",
                    "forgotpassword-username": ".Username is required",
                    "forgotpassword-email": ".Email is required",
                    "forgotpassword-password": ".Password is required",
                    "forgotpassword-confirmpassword": ".Password confirmation is required"
                }
                for (const x in elementsToCheck) {
                    const elementId = elementsToCheck[x]
                    const element = document.getElementById(elementId).value.trim()
                    if (element.length === 0) {
                        fail = setValue(elementId, failedTextColour, `${elementId}-incomplete`, elementMessages[elementId], true)
                    }
                }
                if (firstNameInput.length > 0 && lastNameInput.length > 0 && usernameInput.length > 0 && emailInput.length > 0 && (passwordInput.length > 0 || confirmPasswordInput.length > 0)) {
                    if (passwordInput !== confirmPasswordInput) {
                        fail = setValue("forgotpassword-password", failedTextColour, "forgotpassword-password-incomplete", ".Passwords do not match", true)
                        setValue("forgotpassword-confirmpassword", failedTextColour, "forgotpassword-confirmpassword-incomplete", ".Passwords do not match", true)
                    } else if (passwordInput.length < passwordMinLength || passwordInput.length > passwordMaxLength) {
                        fail = setValue("forgotpassword-password", failedTextColour, "forgotpassword-password-incomplete", ".Password must be between 8-128 characters", true)
                        setValue("forgotpassword-confirmpassword", failedTextColour, "forgotpassword-confirmpassword-incomplete", ".Password must be between 8-128 characters", true)
                    } else if (!responseText.validInformation) {
                        fail = true
                        document.getElementById("forgotpassword-incorrect").innerText = "Unable to reset password - Invalid Credentials"
                        for (const x in elementsToCheck) {
                            document.getElementById(elementsToCheck[x]).style.borderColor = failedTextColour
                        }
                    }
                }
                if (!fail) { // Allow user to change password
                    const formData = {
                        "type": "resetpassword",
                        "username": usernameInput,
                        "newpassword": passwordInput
                    }
                    postAjax("/resetpassword", formData, false, false, "")
                    document.getElementById("forgotpassword-incorrect").classList.add("successful")
                    document.getElementById("forgotpassword-incorrect").innerText = "Successfully Reset Password"
                }
            } catch (error) {
            console.log(error)
            }
        })()
        return false
    }

    function ValidateSignUpForm() {
        /**
         * Function for validating the signup form
         * :return: false in order to cancel the submission of the form
         */
        (async () => { // Use an async to get whether the username & email are already used in the database
            try { // use try catch just in case
                const usernameInput = document.getElementById("signup-username").value.trim()
                const emailInput = document.getElementById("signup-email").value.trim()
                const data = {email: emailInput, username: usernameInput}
                const response = await fetch('/getsignupinformation', { // fetch /getsignupinformation from app.py
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify(data) // parse through the data (email and username input)
                })
                const responseText = await response.json() // wait for the response
                let usernameInUse = responseText.usernameUsed
                let emailInUse = responseText.emailUsed
                // clear the text and colour from previous errors
                clearText(["signup-button-incomplete", "signup-firstname-incomplete", "signup-lastname-incomplete", "signup-username-incomplete", "signup-email-incomplete",
                    "signup-password-incomplete", "signup-confirmpassword-incomplete"])
                clearColour(["teacher-button", "student-button", "signup-firstname", "signup-lastname", "signup-username", "signup-email", "signup-password", "signup-confirmpassword"])
                let fail = false // variable used throughout the check if the data the user inputted is valid
                const teacherButton = document.getElementById("teacher-button").classList.contains("active")
                const studentButton = document.getElementById("student-button").classList.contains("active")
                if (!studentButton && !teacherButton) { // If a button isn't selected, highlight this as an error
                    document.getElementById("teacher-button").style.borderColor = failedTextColour
                    fail = setValue("student-button", failedTextColour, "signup-button-incomplete", ".Selecting student or teacher is required", true)
                }
                // Iterate over fields to check if they have any input, if they don't notify their respected error message
                const elementsToCheck = ["signup-firstname", "signup-lastname", "signup-username", "signup-email", "signup-password", "signup-confirmpassword"]
                const elementMessages = {
                    "signup-firstname": ".First name is required",
                    "signup-lastname": ".Last name is required",
                    "signup-username": ".Username is required",
                    "signup-email": ".Email is required",
                    "signup-password": ".Password is required",
                    "signup-confirmpassword": ".Password confirmation is required"
                }
                for (const x in elementsToCheck) {
                    const elementId = elementsToCheck[x]
                    const element = document.getElementById(elementId).value.trim()
                    if (element.length === 0) {
                        fail = setValue(elementId, failedTextColour, `${elementId}-incomplete`, elementMessages[elementId], true)
                    }
                }
                const firstNameInput = document.getElementById("signup-firstname").value.trim()
                if (firstNameInput.length > firstnameMaxLength) { // Limit first name input to 64 characters
                    fail = setValue("signup-firstname", failedTextColour, "signup-firstname-incomplete", ".First name must be no more than 64 characters", true)
                }
                const lastNameInput = document.getElementById("signup-lastname").value.trim()
                if (lastNameInput.length > lastnameMaxLength) { // Limit last name input to 64 characters
                    fail = setValue("signup-lastname", failedTextColour, "signup-lastname-incomplete", ".Last name must be no more than 64 characters", true)
                }
                if (usernameInput.length > usernameMaxLength) { // Limit username name input to 64 characters
                    fail = setValue("signup-username", failedTextColour, "signup-username-incomplete", ".Username must be no more than 32 characters", true)
                } else if (usernameInUse) { // Disallow duplicate usernames
                    fail = setValue("signup-username", failedTextColour, "signup-username-incomplete", ".This username is already in use", true)
                }
                if (emailInput.length > 0) { // Ensure that the email input is at least one character long
                    if (emailInput.length > emailMaxLength || emailInput.length < emailMinLength) { // Limit email address to be between 4-256 characters
                        fail = setValue("signup-email", failedTextColour, "signup-email-incomplete", ".Email must be between 4-256 characters", true)
                    } else if (!(emailInput.includes('@') && emailInput.split('@')[emailInput.split('@').length - 1].includes('.'))) {
                        // "very.(),:;<>[]\".VERY.\"very@\\ \"very\".unusual"@strange.example.com <- this email address is valid, so this should accept that
                        fail = setValue("signup-email", failedTextColour, "signup-email-incomplete", ".Email must include '@' and '.' afterwards", true)
                    } else if (emailInUse) { // Disallow duplicate email addresses
                        fail = setValue("signup-email", failedTextColour, "signup-email-incomplete", ".This email address is already in use", true)
                    }
                }
                const passwordInput = document.getElementById("signup-password").value.trim()
                const confirmPasswordInput = document.getElementById("signup-confirmpassword").value.trim()
                if (passwordInput.length > 0 || confirmPasswordInput.length > 0) { // Ensure that the password input or confirm password input is at least one character long
                    if (passwordInput.length > 0 && passwordInput !== confirmPasswordInput) { // passwords must be equal
                        fail = setValue("signup-password", failedTextColour, "signup-password-incomplete", ".Passwords do not match", true)
                        setValue("signup-confirmpassword", failedTextColour, "signup-confirmpassword-incomplete", ".Passwords do not match", true)
                    } else if (passwordInput.length < passwordMinLength || passwordInput.length > passwordMaxLength) { // password should have to be 8-128 characters
                        fail = setValue("signup-password", failedTextColour, "signup-password-incomplete", ".Password must be between 8-128 characters", true)
                        setValue("signup-confirmpassword", failedTextColour, "signup-confirmpassword-incomplete", ".Password must be between 8-128 characters", true)
                    }
                }
                if (!fail) { // Data has been validated, sign up the user
                    const formData = {
                        "type": "signup",
                        "role": document.getElementById("teacher-button").classList.contains("active"),
                        "firstname": document.getElementById("signup-firstname").value,
                        "lastname": document.getElementById("signup-lastname").value,
                        "username": document.getElementById("signup-username").value,
                        "email": document.getElementById("signup-email").value,
                        "password": document.getElementById("signup-password").value
                    }
                    postAjax("/signup", formData, false, false, "")
                    signUpModal.modal('hide') // close sign up modal
                    loginModal.modal('show') // open login modal
                }
            } catch (error) {
                console.error(error)
            }
        })()
        return false // cancel the form as the data is being managed by ajax
    }

    $('#student-button').click(function() {
        /** Manage the student button click event by adding an active class */
        if (!document.getElementById("student-button").classList.contains("active")) {
            document.getElementById("student-button").classList.add("active")
            removeTeacherButtonInput()
        } else {
            removeStudentButtonInput()
        }
    })

    $('#teacher-button').click(function() {
        /** Manage the teacher button click event by adding an active class */
        if (!document.getElementById("teacher-button").classList.contains("active")) {
            document.getElementById("teacher-button").classList.add("active")
            removeStudentButtonInput()
        } else {
            removeTeacherButtonInput()
        }
    })

    $('#login').click(function() {
        /** Hide the scrollbar when the user clicks the login */
        document.body.style.overflow = "hidden"
    })

    function checkModalVisibility() {
        /** Ensures that the whether the scroll bar is visible is only set to auto if all the modals are hidden */
        if (!loginModal.is(':visible') && !forgotPasswordModal.is(':visible') && !signUpModal.is(':visible')) {
            document.body.style.overflow = "auto"
        }
    }

    loginModal.on('hidden.bs.modal', function() {
        /**
         * Function which is called on the login modal close event
         * This will clear all the values related to the login modal and call checkModalVisibility()
         */
        checkModalVisibility()
        document.getElementById("login-show-password").checked = false // Set the checked value to false
        clearValue(["login-username", "login-password"])
        clearText(["login-incorrect", "login-username-incomplete", "login-password-incomplete"])
        clearColour(["login-username", "login-password"])
    })

    forgotPasswordModal.on('hidden.bs.modal', function() { // Forgot password modal close event
        /**
         * Function which is called on the forgot password modal close event
         * This will clear all the values related to the forgot password modal and call checkModalVisibility()
         */
        checkModalVisibility()
        document.getElementById("forgotpassword-show-password").checked = false // Set the checked value to false
        document.getElementById("forgotpassword-incorrect").classList.remove("successful")
        clearValue(["forgotpassword-firstname", "forgotpassword-lastname", "forgotpassword-username", "forgotpassword-email", "forgotpassword-password", "forgotpassword-confirmpassword"])
        clearText(["forgotpassword-incorrect", "forgotpassword-firstname-incomplete", "forgotpassword-lastname-incomplete", "forgotpassword-username-incomplete",
            "forgotpassword-email-incomplete", "forgotpassword-password-incomplete", "forgotpassword-confirmpassword-incomplete"])
        clearColour(["forgotpassword-firstname", "forgotpassword-lastname", "forgotpassword-username", "forgotpassword-email", "forgotpassword-password", "forgotpassword-confirmpassword"])
    })

    signUpModal.on('hidden.bs.modal', function() {
        /**
         * Function which is called on the signup modal close event
         * This will clear all the values related to the signup modal and call checkModalVisibility()
         */
        checkModalVisibility()
        document.getElementById("signup-show-password").checked = false // Set the checked value to false
        removeTeacherButtonInput()
        removeStudentButtonInput()
        clearValue(["teacher-button", "student-button", "signup-firstname", "signup-lastname", "signup-username", "signup-email", "signup-password", "signup-confirmpassword"])
        clearText(["signup-button-incomplete", "signup-firstname-incomplete", "signup-lastname-incomplete", "signup-username-incomplete", "signup-email-incomplete",
            "signup-password-incomplete", "signup-confirmpassword-incomplete"])
        clearColour(["teacher-button", "student-button", "signup-firstname", "signup-lastname", "signup-username", "signup-email", "signup-password", "signup-confirmpassword"])
    })

    $('.closeLoginModal').click(function() {
        /** On clicking login modal close button, close modal (this is a class as it is called multiple times) */
        loginModal.modal('hide')
    })

    $('#closeForgotPasswordModal').click(function() {
        /** On clicking forgot password modal close button, close modal */
        forgotPasswordModal.modal('hide')
    })

    $('#closeSignUpModal').click(function() {
        /** On clicking sign up modal close button, close modal */
        signUpModal.modal('hide')
    })

    // For the categories.html
    function handleSortChange() {
        /** Handle when the user changes the sorting methods for the words */
        const selectedValue = document.getElementById("sorting-methods").value
        const formData = {
            "type": "sorting-methods",
            "selectedvalue": selectedValue
        }
        postAjax("{{url_for('categories', category='all-categories', page=1)}}", formData, true, false, "")
    }

    function handleWordsPerPage() {
        /** Handle when the user changes the amount of words displaying per page */
        const selectedValue = document.getElementById("words-per-page").value
        const formData = {
            "type": "words-per-page",
            "selectedvalue": selectedValue
        }
        const wordsSelector = $("#words-per-page")
        const previousValue = wordsSelector.data("previous-value")
        const currentCategory = wordsSelector.data("category")
        const oldPage = wordsSelector.data("old-page")
        let newPage = 1
        if (selectedValue !== "All" && previousValue !== "All") {
            newPage = Math.floor((previousValue / selectedValue) * (oldPage - 1)) + 1
        }
        postAjax("{{url_for('categories', category='all-categories', page=1)}}", formData, false, true, `/categories/${currentCategory}/${newPage}`)
    }

    $('#switch-language').click(function() {
        /** Function for switching the currently selected language */
        const language = document.getElementById("category-language-background").innerText
        let newLanguage; // prevents any errors (e.g. if it is for some reason another string)
        if (language === "English-Māori") {
            document.getElementById("category-language-background").innerText = "Māori-English"
            newLanguage = "Māori-English"
        } else {
            document.getElementById("category-language-background").innerText = "English-Māori"
            newLanguage = "English-Māori"
        }
        const formData = {
            "type": "category-language",
            "language": newLanguage
        }
        // Now need to fix this!
        postAjax("{{url_for('categories', category='all-categories', page=1)}}", formData, true, false, "")
    })

    requestAnimationFrame(function() {
        /**
         * This function is providing as a failsafe to make sure what is displayed in the navigation bar is correct
         * This function is called when the window is animated
        */
        //checkLogin({{ logged_in }}, {{ admin_clean }})
        setImgSize()
    })

    function setImgSize() {
        /** This function sets the size of the image proportional to the container size after it has been loaded */
        const images = document.getElementsByClassName("word-table-image")
        const textContainers = document.getElementsByClassName("text")
        const imageContainers = document.getElementsByClassName("word-table-image-container")
        for (let i = 0; i < images.length; i++) {
            const containerWidth = imageContainers[i].clientWidth
            const imgWidth = images[i].naturalWidth
            const imgHeight = images[i].naturalHeight
            const aspectRatio = imgWidth / imgHeight
            let newHeight = containerWidth / aspectRatio
            let maxHeight = textContainers[i].clientHeight
            if (newHeight > maxHeight) {
                newHeight = maxHeight
            }
            images[i].style.width = containerWidth + "px"
            images[i].style.height = newHeight + "px"
        }
    }

    // Set the image size when the page is resized
    window.addEventListener("resize", setImgSize)

    const collapsible = document.getElementById("level-filters-collapsible")
    collapsible.addEventListener("click", function() {
        /** Manage the text and display of the level collapsible when it is clicked */
        this.classList.toggle("active-level-filter")
        const content = this.nextElementSibling
        const expandedLevelFilters = document.getElementById("expand-level-filters")
        if (content.style.display === "block") {
            expandedLevelFilters.innerText = "+"
            content.style.display = "none"
        } else { // Selected
            expandedLevelFilters.innerText = "-"
            content.style.display = "block"
        }
    })

    const previousCheckboxes = document.querySelectorAll('.level-filter-check');
    const previousCheckboxStates = {}
    // Manage the states of the level filter checkbox states
    previousCheckboxes.forEach((checkbox) => {
          previousCheckboxStates[checkbox.id] = checkbox.checked
    })
    localStorage.setItem('storedCheckboxStates', JSON.stringify(previousCheckboxStates))

    function manageCheckboxes() {
        /**
         * Function for managing the checkboxes
         * This ensures that there will always be a checkbox selected,
         * and that no other checkboxes can be selected if the all categories checkbox is selected
         */
        const checkboxes = document.querySelectorAll('.level-filter-check')
        const storedCheckboxStates = JSON.parse(localStorage.getItem('storedCheckboxStates'))
        const checkboxStates = {}
        checkboxes.forEach((checkbox) => {
              checkboxStates[checkbox.id] = checkbox.checked
        })
        if (storedCheckboxStates["level-filter-all"] && checkboxStates["level-filter-all"]) {
            // Previous state was true and new state is true
            // check if any other checkbox has been set to true
            let anyTrueCheckbox = false
            for (const checkbox in checkboxStates) {
                if (checkbox === "level-filter-all") {
                    continue; // Skip the level-filter-all checkbox
                }
                if (checkboxStates[checkbox]) {
                    anyTrueCheckbox = true
                    break;
                }
            }
            if (anyTrueCheckbox) {
                const allCheckbox = document.getElementById("level-filter-all")
                allCheckbox.checked = false
                checkboxStates["level-filter-all"] = false
            }
        } else if (!storedCheckboxStates["level-filter-all"] && checkboxStates["level-filter-all"]) {
            // Previous state was false and new state is true
            // set all other checkboxes to false
            for (const checkbox in checkboxStates) {
                if (checkbox === "level-filter-all") {
                    continue; // Skip the level-filter-all checkbox
                }
                const currentCheckbox = document.getElementById(checkbox)
                currentCheckbox.checked = false
                checkboxStates[checkbox] = false
            }
        } else if (storedCheckboxStates["level-filter-all"] && !checkboxStates["level-filter-all"]) {
            // Previous state was true and new state is false
            const anyTrueCheckbox = Object.values(checkboxStates).some((checked) => checked)
            if (!anyTrueCheckbox) {
                const currentCheckbox = document.getElementById("level-filter-all")
                currentCheckbox.checked = true
                checkboxStates["level-filter-all"] = true
            }
        } else {
            // Previous state was false and new state is false
            // user cannot unselect
            const anyTrueCheckbox = Object.values(checkboxStates).some((checked) => checked)
            if (!anyTrueCheckbox) {
                for (const checkbox in checkboxStates) {
                    if (checkboxStates[checkbox] !== storedCheckboxStates[checkbox]) {
                        const currentCheckbox = document.getElementById(checkbox)
                        currentCheckbox.checked = true
                        checkboxStates[checkbox] = true
                        break;
                    }
                }
            }
        }
        // Store the checkbox states in local storage
        localStorage.setItem('storedCheckboxStates', JSON.stringify(checkboxStates))
    }

    const levelCheckbox = document.querySelectorAll(".level-filter-check")
    levelCheckbox.forEach(levelCheckbox => {
        /** Manage the checkboxes when an element with the class level-filter-check is clicked */
        levelCheckbox.addEventListener('click', (event) => {
            // This stops the event
            event.stopPropagation()
            manageCheckboxes()
        })
    })

    const levelFilters = document.querySelectorAll(".button-level-filter")
    levelFilters.forEach(levelFilters => {
        /**
         * Manage the checkboxes when an element with the class button-level-filter is clicked,
         * also change the checkbox state of the level filters
         */
        levelFilters.addEventListener('click', () => {
            const checkbox = levelFilters.querySelector('input[type="checkbox"]')
            checkbox.checked = !checkbox.checked
            manageCheckboxes()
        })
    })

    const levelFilterSubmit = document.getElementById("button-level-submit")
    levelFilterSubmit.addEventListener('click', () => {
        /**
         * Function which is called when the user submits their changes to the levels
         * This posts an ajax request with the current selected checkboxes
         */
        const activeCheckboxStates = JSON.parse(localStorage.getItem('storedCheckboxStates'))
        let activeCheckboxes = []
        for (const checkbox in activeCheckboxStates) {
            if (activeCheckboxStates[checkbox]) {
                activeCheckboxes.push(checkbox.replace("level-filter-", ""))
            }
        }
        const formData = {
            "type": "level-filter",
            "checkboxes": activeCheckboxes
        }
        const currentCategory = $("#button-level-submit").data("category")
        postAjax("{{url_for('categories', category='all-categories', page=1)}}", formData, false, true, `/categories/${currentCategory}/1`) // redirect to first pay
    })

    function validateAddWord() {
        /**
         * Function for validating the addition of a new word
         * This get the english word, maori word, and definition then check if it meets the given parameters,
         * if anything doesn't meet the given parameters, then return an appropriate error message
         */
        (async () => { // Use an async to get whether the word is already used in the database
            try {
                const englishWord = document.getElementById("english-word").value.trim()
                const maoriWord = document.getElementById("maori-word").value.trim()
                const definition = document.getElementById("word-definition").value.trim()
                clearText(["word-definition-incomplete"])
                clearColour(["word-definition"])
                if (definition.length === 0) {
                    setValue("word-definition", failedTextColour, "word-definition-incomplete", ".Word definition is required")
                } else if (definition.length > definitionMaxLength) {
                    setValue("word-definition", failedTextColour, "word-definition-incomplete", ".Word definition must be no longer than 128 characters")
                }
                /** Ensure that there are no special characters
                * /: The starting delimiter of the regular expression.
                * ^: Anchors the match to the beginning of the string.
                * [a-z|āēīōū]: Character set that matches any lowercase letter (a-z) or the specific characters ā, ē, ī, ō, ū.
                * \s: Matches any whitespace.
                * +: Quantifier that matches one or more occurrences of the preceding pattern (the character set).
                * $: Anchors the match to the end of the string.
                * /: The ending delimiter of the regular expression.
                */
                let validEnglishWord = /^[a-z|āēīōū\s]+$/.test(englishWord.toLowerCase())
                let validMaoriWord = /^[a-z|āēīōū\s]+$/.test(maoriWord.toLowerCase())
                if (englishWord.length > 0 && maoriWord.length > 0 && englishWord.length <= wordMaxLength && maoriWord.length <= wordMaxLength && validEnglishWord && validMaoriWord) {
                    const data = {english: englishWord, maori: maoriWord}
                    const response = await fetch('/getwordinformation', { // fetch /getwordinformation from app.py
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(data) // parse through the data (email and username input)
                    })
                    const responseText = await response.json() // wait for the response
                    /* Words can translate into multiple different words in other languages,
                    * only disallow repeated entries for both the word and the translated word */
                    let englishInUse = responseText.hasEnglishWord
                    let maoriInUse = responseText.hasMaoriWord
                    if (englishInUse && maoriInUse) {
                        setValue("english-word", failedTextColour, "english-word-incomplete", ".This word is already in use")
                        setValue("maori-word", failedTextColour, "maori-word-incomplete", ".This word is already in use")
                    } else {
                        clearText(["english-word-incomplete", "maori-word-incomplete"])
                        clearColour(["english-word", "maori-word"])
                        if (definition.length > 0 && definition.length <= definitionMaxLength) {
                            const category = document.getElementById("word-select-category")
                            const level = document.getElementById("level-select-category")
                            const image = document.getElementById("image-upload")
                            // Display the modal
                            addWordModal.modal('show')
                            // Modify the elements on the modal
                            document.getElementById("add-word-modal-english-word").innerText = "English Word: " + englishWord
                            document.getElementById("add-word-modal-maori-word").innerText = "Māori Word: " + maoriWord
                            document.getElementById("add-word-modal-definition").innerText = "Definition: " + definition
                            // Turn the category innerText into an array by splitting at each new line, then get the category name (category value starts at 1)
                            document.getElementById("add-word-modal-category").innerText = "Category: " + category.options[category.selectedIndex].text
                            document.getElementById("add-word-modal-level").innerText = "Level: " + level.value
                            const previewContainer = document.getElementById('add-word-modal-image');
                            if (image.files.length > 0) { // User has attached an image
                                let reader = new FileReader(); // Create a new FileReader() object
                                reader.onload = function (e) {
                                    let imageElement = document.createElement('img');
                                    imageElement.src = e.target.result.toString();
                                    // Append the image element to the preview container
                                    previewContainer.innerHTML = "";
                                    previewContainer.appendChild(imageElement);
                                };
                                reader.readAsDataURL(image.files[0]);
                            } else {
                                previewContainer.innerHTML = "";
                            }
                        }
                    }
                } else {
                    clearText(["english-word-incomplete", "maori-word-incomplete"])
                    clearColour(["english-word", "maori-word"])
                    if (!validEnglishWord) {
                        setValue("english-word", failedTextColour, "english-word-incomplete", ".Word can only contain alphabetical values")
                    }
                    if (!validMaoriWord) {
                        setValue("maori-word", failedTextColour, "maori-word-incomplete", ".Word can only contain alphabetical values")
                    }
                    if (englishWord.length === 0) {
                        setValue("english-word", failedTextColour, "english-word-incomplete", ".English word is required")
                    }
                    if (maoriWord.length === 0) {
                        setValue("maori-word", failedTextColour, "maori-word-incomplete", ".Māori word is required")
                    }
                    if (englishWord.length > wordMaxLength) {
                        setValue("english-word", failedTextColour, "english-word-incomplete", `.English word must be no longer than ${wordMaxLength} characters`)
                    }
                    if (maoriWord.length > wordMaxLength) {
                        setValue("maori-word", failedTextColour, "maori-word-incomplete", `.Māori word must be no longer than ${wordMaxLength} characters`)
                    }
                }
            } catch (error) {
                console.error(error)
            }
        })()
    }

    function submitAddWordForm() {
        /** This function is for submitting the validated word into the app.py */
        // Cannot use an object literal here as I am also managing data with an image
        let formData = new FormData();
        const englishWord = document.getElementById("english-word").value.trim()
        const maoriWord = document.getElementById("maori-word").value.trim()
        const definition = document.getElementById("word-definition").value.trim()
        const category = document.getElementById("word-select-category").value
        const level = document.getElementById("level-select-category").value
        const image = document.getElementById("image-upload")
        formData.append("englishWord", englishWord)
        formData.append("maoriWord", maoriWord)
        formData.append("definition", definition)
        formData.append("category", category)
        formData.append("level", level)
        if (image.files.length > 0) {
            formData.append("image", image.files[0])
        }
        $.ajax({
            type: 'POST',
            url: "/addword",
            data: formData,
            processData: false, // Prevents jQuery from automatically converting data to string
            contentType: false, // Tells jQuery not to set any content type header
            success: function () {
                addWordModal.modal('hide')
                updateDeleteWord(englishWord, maoriWord)
            }
        })
        // Clear all the text boxes
        document.getElementById("english-word").value = ""
        document.getElementById("maori-word").value = ""
        document.getElementById("word-definition").value = ""
        const categoryElement = document.getElementById("word-select-category")
        if (categoryElement.options.length > 0) { // Incase all categories are deleted for some reason
            categoryElement.value = categoryElement.options[0].value
        }
        const levelElement = document.getElementById("level-select-category")
        if (levelElement.options.length > 0) { // Incase all levels are deleted for some reason
            levelElement.value = levelElement.options[0].value
        }
        image.value = ""
    }

    function replaceMacrons(inputString) {
        /**
         * This function is for replacing macrons in maori in place of a corresponding latin character
         * This is useful for using sorted() in order to sort words by alphabetical order
         * as macrons are placed weirdly lexicographically
         */
        let macrons = ['ā', 'ē', 'ī', 'ō', 'ū']
        let characters = ['a', 'e', 'i', 'o', 'u']
        for (let i = 0; i < macrons.length; i++) {
            inputString = inputString.replace(macrons[i], characters[i])
        }
        return inputString;
    }

    function updateDeleteWord(englishWord, maoriWord) {
        /**
         * This function is called when the user has added a word into their database,
         * this adds the newly added word into the word list in 'Delete Word',
         * allowing administrators to delete newly added words
         */
        (async() => {
            try {
                const data = {english: englishWord, maori: maoriWord}
                const response = await fetch('/getwordidfromword', { // fetch /getwordidfromword from app.py
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                })
                const responseText = await response.json() // wait for the response
                let wordId = responseText.wordId
                const englishDeleteWord = document.getElementById("englishword-select-category")
                let englishNodes = englishDeleteWord.options
                let englishOptions = []
                for (let i = 0; i < englishNodes.length; i++) {
                    // Append the options into a new array
                    englishOptions.push(englishNodes[i]) // Need to do a regex here to replace all macros with english characters
                }
                const newEnglishOption = new Option(englishWord.toLowerCase(), wordId)
                englishOptions.push(newEnglishOption)
                englishOptions.sort((a, b) => replaceMacrons(a.text) > replaceMacrons(b.text) ? 1 : -1) // Moves to left or right
                // Need to set the options now
                let originalValue = englishDeleteWord.value;
                for (let i = 0; i < englishOptions.length; i++) {
                    englishNodes[i] = englishOptions[i]
                }
                englishDeleteWord.value = originalValue;
                const maoriDeleteWord = document.getElementById("maoriword-select-category")
                let maoriNodes = maoriDeleteWord.options
                let maoriOptions = []
                for (let i = 0; i < maoriNodes.length; i++) {
                    // Append the options into a new array
                    maoriOptions.push(maoriNodes[i])
                }
                const newMaoriOption = new Option(maoriWord.toLowerCase(), wordId)
                maoriOptions.push(newMaoriOption)
                maoriOptions.sort((a, b) => replaceMacrons(a.text) > replaceMacrons(b.text) ? 1: -1)
                // Set the options
                for (let i = 0; i < maoriOptions.length; i++) {
                    maoriNodes[i] = maoriOptions[i]
                }
                maoriDeleteWord.value = originalValue
            } catch (error) {
                console.log(error)
            }
        })()
    }

    function handleDeleteEnglishWordChange(selectedElement) {
        /**
         * This function handles the english word dropdown in the delete word section,
         * automatically selecting the corresponding maori word
        */
        const selectedOption = selectedElement.value;
        const maoriList = document.getElementById("maoriword-select-category")
        maoriList.value = selectedOption
    }

    function handleDeleteMaoriWordChange(selectedElement) {
        /**
         * This function handles the maori word dropdown in the delete word section,
         * automatically selecting the corresponding english word
        */
        const selectedOption = selectedElement.value;
        const englishList = document.getElementById("englishword-select-category")
        englishList.value = selectedOption
    }

    function deleteWordModalConfirmation() {
        /** This function is for the delete word modal, and allows the user to see the information about the word before confirming deletion */
        (async() => {
            try {
                const imageContainer = document.getElementById("delete-word-modal-image")
                imageContainer.innerHTML = ""
                deleteWordModal.modal('show')
                const wordId = document.getElementById("englishword-select-category").value // Will be same for maori word
                const data = {id: wordId}
                const response = await fetch('/getwordfromid', { // fetch /getwordinformation from app.py
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data) // parse through the data (email and username input)
                })
                const responseText = await response.json()
                const englishWord = responseText.englishWord
                const maoriWord = responseText.maoriWord
                const wordDefinition = responseText.wordDefinition
                const category = responseText.category
                const wordLevel = responseText.wordLevel
                let relativePath = "/static/images/noimage.png";
                if (responseText.wordImage != null) {
                    relativePath = `/static/images/${responseText.wordImage}`
                }
                const fullPath = window.location.origin + relativePath;
                // Create a new <img> element
                let img = document.createElement("img");
                img.src = fullPath
                imageContainer.appendChild(img);
                document.getElementById("delete-word-modal-english-word").innerText = "English Word: " + englishWord
                document.getElementById("delete-word-modal-maori-word").innerText = "Māori Word: " + maoriWord
                document.getElementById("delete-word-modal-definition").innerText = "Definition: " + wordDefinition
                document.getElementById("delete-word-modal-category").innerText = "Category: " + category
                document.getElementById("delete-word-modal-level").innerText = "Level: " + wordLevel
            } catch (error) {
                console.log(error)
            }
        })()
    }

    function submitDeleteWordForm() {
        /**
         * Post the delete word form data to the app.py to delete the word from the database,
         * then ensure that any instance of this word is removed from the others forms in the admin section
        */
        const wordId = document.getElementById("englishword-select-category").value
        const formData = {
            "wordId": wordId
        }
        postAjax('/deleteword', formData, false, false, "")
        // Need to update the dropdowns with the new data
        const englishWord = document.getElementById("englishword-select-category");
        let englishOptionToRemove = englishWord.querySelector("option[value='" + wordId + "']");
        englishWord.removeChild(englishOptionToRemove);
        const maoriWord = document.getElementById("maoriword-select-category");
        let maoriOptionToRemove = maoriWord.querySelector("option[value='" + wordId + "']");
        maoriWord.removeChild(maoriOptionToRemove);
        handleDeleteEnglishWordChange(englishWord)
        deleteWordModal.modal('hide')
    }

    function capitaliseFirstCharEachWord(string) {
        /**
        * \b matches a word boundary, ensuring to make the first character of each word
        * \w matches a word character
        * g is used to perform a global search
         */
        return string.toLowerCase().replace(/\b\w/g, match => match.toUpperCase());
    }

    function validateAddCategoryForm() {
        /** Function for validating the add category form information in order to return any errors back to the user */
        let categoryName = document.getElementById("add-category-category").value.trim()
        if (categoryName.length <= 0 || categoryName.length > categoryMaxLength) {
            setValue("add-category-category", failedTextColour, "add-category-category-incomplete", `.The category name must be between 0 and ${categoryMaxLength} characters`)
        } else {
            (async () => {
                try {
                    const data = {category: categoryName}
                    const response = await fetch('/hascategory', { // fetch /hascategory from app.py
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(data)
                    })
                    const responseText = await response.json()
                    let hasCategory = responseText.hasCategory
                    if (hasCategory) {
                        setValue("add-category-category", failedTextColour, "add-category-category-incomplete", ".This category name is already in use")
                    } else { // Passed all test cases
                        clearText(["add-category-category-incomplete"])
                        clearColour(["add-category-category"])
                        document.getElementById("add-category-modal-category-name").innerText = "Category Name: " + capitaliseFirstCharEachWord(categoryName)
                        addCategoryModal.modal('show')
                    }
                } catch (error) {
                    console.log(error)
                }
            })()
        }
    }

    function manageNewCategory(categoryName) {
        /** Manage the addition of a new category */
        (async() => {
            try {
                const data = {categoryName: categoryName}
                const response = await fetch('/getcategoryid', { // fetch /getcategoryid from app.py
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                })
                const responseText = await response.json() // wait for the response
                const categoryId = responseText.categoryId
                // Now manage the category list in add word and delete category
                const addWordCategories = document.getElementById("word-select-category")
                let addWordCategoryNodes = addWordCategories.options
                // .options returns a collection, so parse everything to a new array
                let addWordCategoryOptions = []
                for (let i = 0; i < addWordCategoryNodes.length; i++) {
                    // Append the options into a new array
                    addWordCategoryOptions.push(addWordCategoryNodes[i]) // Need to do a regex here to replace all macros with english characters
                }
                const newAddWordCategoryOption = new Option(categoryName, categoryId)
                addWordCategoryOptions.push(newAddWordCategoryOption)
                addWordCategoryOptions.sort((a, b) => replaceMacrons(a.text) > replaceMacrons(b.text) ? 1 : -1) // Moves to left or right
                // Need to set the options now
                let originalValue = addWordCategories.value;
                for (let i = 0; i < addWordCategoryOptions.length; i++) {
                    addWordCategoryNodes[i] = addWordCategoryOptions[i]
                }
                addWordCategories.value = originalValue;
                // Manage delete category list
                const deleteCategoryCategories = document.getElementById("category-name-delete-category")
                let deleteCategoryNodes = deleteCategoryCategories.options
                let deleteCategoryOptions = []
                for (let i = 0; i < deleteCategoryNodes.length; i++) {
                    deleteCategoryOptions.push(deleteCategoryNodes[i])
                }
                const newDeleteCategoryOption = new Option(categoryName, categoryId)
                deleteCategoryOptions.push(newDeleteCategoryOption)
                deleteCategoryOptions.sort((a, b) => replaceMacrons(a.text) > replaceMacrons(b.text) ? 1: -1)
                let originalDeleteCategoryValue = deleteCategoryCategories.value
                for (let i = 0; i < deleteCategoryOptions.length; i++) {
                    deleteCategoryNodes[i] = deleteCategoryOptions[i]
                }
                deleteCategoryCategories.value = originalDeleteCategoryValue
            } catch (error) {
                console.log(error)
            }
        })()
    }

    function addCategory() {
        /** Function for adding a category by posting the information via AJAX and managing the category if the post was successful */
        const categoryName = capitaliseFirstCharEachWord(document.getElementById("add-category-category").value.trim())
        const formData = {
            "categoryName": categoryName
        }
        $.ajax({
            type: 'POST',
            url: "/addcategory",
            data: JSON.stringify(formData),
            processData: false,
            contentType: 'application/json',
            success: function () {
                document.getElementById("add-category-category").value = ""
                addCategoryModal.modal('hide')
                manageNewCategory(categoryName)
            }
        })
    }

    function validateDeleteCategory() {
        /** Display the category name on the delete category confirmation modal when the user is deleting a category */
        deleteCategoryModal.modal('show')
        const categoryList = document.getElementById("category-name-delete-category")
        document.getElementById("delete-category-modal-category-name").innerText = "Category Name: " + categoryList.options[categoryList.selectedIndex].text
    }

    function manageDeleteCategory(categoryName, categoryId) {
        /** Manage the category when the user deletes it (make it so that the user cannot add a word into this category/delete it again) */
        const deleteCategoryCategories = document.getElementById("category-name-delete-category")
        let deleteCategoryNodes = deleteCategoryCategories.options
        let deleteCategoryOptions = []
        for (let i = 0; i < deleteCategoryNodes.length; i++) {
            if (deleteCategoryNodes[i].value !== categoryId) {
                deleteCategoryOptions.push(deleteCategoryNodes[i])
            }
        }
        // Change all the values
        for (let i = 0; i < deleteCategoryOptions.length; i++) {
            deleteCategoryNodes[i] = deleteCategoryOptions[i]
        }
        if (deleteCategoryCategories.value === categoryId) {
            deleteCategoryCategories.value = deleteCategoryNodes[0].value // Set the value back to the first value
        }
        // Manage add word category list
        const addWordCategories = document.getElementById("word-select-category")
        let addWordCategoryNodes = addWordCategories.options
        let addWordCategoryOptions = []
        for (let i = 0; i < addWordCategoryNodes.length; i++) {
            if (addWordCategoryNodes[i].value !== categoryId) {
                addWordCategoryOptions.push(addWordCategoryNodes[i])
            }
        }
        // Change all the values
        for (let i = 0; i < addWordCategoryOptions.length; i++) {
            addWordCategoryNodes[i] = addWordCategoryOptions[i]
        }
        if (addWordCategories.value === categoryId) {
            addWordCategories.value = addWordCategoryNodes[0].value // Set the value back to the first value
        }
    }

    function deleteCategory() {
        /** Post data about the category which the user is deleting to the app.py and delete the category */
        const categoryList = document.getElementById("category-name-delete-category")
        const categoryName = categoryList.options[categoryList.selectedIndex].text
        const categoryId = categoryList.value
        const formData = {
            "categoryName": categoryName
        }
        $.ajax({
            type: 'POST',
            url: "/deletecategory",
            data: JSON.stringify(formData),
            processData: false,
            contentType: 'application/json',
            success: function () {
                deleteCategoryModal.modal('hide')
                manageDeleteCategory(categoryName, categoryId)
            }
        })
    }

    function directlyDeleteWord() {
        /** Directly delete the word from the category list */
        const wordInformation = document.getElementById("translate-header-word").innerText.split("\n")
        const currentWord = wordInformation[0]
        const translatedWord = wordInformation[1]
        const formData = {
            "currentWord": currentWord,
            "translatedWord": translatedWord
        }
        postAjax("/deletewordfromdata", formData, false, true, "/categories/all-categories/1")
        directDeleteWordModal.modal('hide')
    }

    function validateSearchForm() {
        /** Validate the home page/translate page search form to make sure that the search isn't empty */
        return document.getElementById('text').value.trim().length > 0
    }

    function validateCategorySearch() {
        /** Validate the category page search form to make sure that the search isn't empty */
        return document.getElementById('category-search-bar').value.trim().length > 0
    }
</script>
</html>